#include "lib.h"

/* Library for SEAMScript runtime */

entity_node* ehead = NULL; //Entity list
alloc_node* ahead = NULL; //Allocation list
int quit_requested = 0;

SDL_Window* sdl_window = NULL; //SDL window
SDL_Surface* sdl_screen_surface = NULL;
int window_inited = 0; //Have we created an SDL window?
keyboard_node* khead = NULL;

/* Memory management */

//Construct a node and add it to the list. */
void _make_node(void* ptr){
	alloc_node* curr = ahead;
	while(curr && curr->next) { curr = curr->next; }
	//curr contains the last element

	alloc_node* new_node = malloc(sizeof(alloc_node));
	if(!new_node) _seam_fatal("Failed to allocate allocation node!");
	
	new_node->next = NULL;
	new_node->ptr = ptr;
	new_node->ref_count = 0;
			
	//Add it to the list
	if(curr)
		curr->next = new_node; 
	else
		ahead = new_node;
}

//Only used by other lib.c functions.
alloc_node* _find_alloc_node(void* ptr){
	alloc_node* curr = ahead;
	while(curr){
		if(curr->ptr == ptr) return curr;
		curr = curr->next;
	}

	return NULL;
}

//Increment refrence count for a pointer (could be absent from list).
void _increment_refs(void* ptr){
	alloc_node* curr = _find_alloc_node(ptr);
	if(curr) curr->ref_count = curr->ref_count + 1;
}

//Decrement reference count for a pointer (could be absent from list).
void _decrement_refs(void* ptr){
	alloc_node* curr = _find_alloc_node(ptr);
	if(curr) curr->ref_count = curr->ref_count - 1;
}

//Garbage collection.
void _gc(){
	alloc_node* curr = ahead;

	//Free up list elements
	while(curr != NULL){
		if(curr->ref_count == 0){
			//printf("Freeing a node's pointer...\n");
			free(curr->ptr);
		}

		curr = curr->next;
	}

	//Free nodes and invalidate pointer
	alloc_node* prev = NULL;
	curr = ahead;
	while(curr != NULL){
		alloc_node* next = curr->next;

		if(curr->ref_count == 0){
			if(prev != NULL){
				prev->next = NULL; //Invalidate last pointer if not head
	//			printf("Invaliding last pointer...\n");
			}
			if(curr == ahead){
				ahead = next; //Move head, if needed
	//			printf("Moved head forward\n");
			}

			free(curr);
			curr = NULL;
		}

		if(curr != NULL){
			prev = curr; //Move previous if this was valid
	//		printf("Moved previous pointer\n");
		}
		curr = next;
	}
}

/* Runtime errors */

void _seam_fatal(char* err){
	fprintf(stderr, "%s\n", err);
	exit(1);
}

/* Entity management */

//Mostly generated by the compiler, but we have a stub implementation.
void stub(void* data){ /* Stubby. */ }

/* 'convert' entity */

char* _convert_string_join(char* str1, char* str2){
	int str1len = strlen(str1);
	int str2len = strlen(str2);

	int len = str1len + str2len + 1;
	char* buf = malloc(sizeof(char) * len);
	if(!buf) _seam_fatal("Failed to allocate for string join!");
	strcpy(buf, str1);
	strcpy( (buf + str1len) , str2);
	_make_node(buf);
	return buf;
}

char* _convert_int_to_str(int input){
	ssize_t expected = snprintf(NULL, 0, "%d", input);
	char* buf = malloc(sizeof(char) * (expected + 1));
	if(!buf) _seam_fatal("Failed to allocate buf for int to string!");
	snprintf(buf, expected + 1, "%d", input);
	_make_node(buf);
	return buf;
}

char* _convert_float_to_str(float input){
	ssize_t expected = snprintf(NULL, 0, "%f", input);
	char* buf = malloc(sizeof(char) * (expected + 1));
	if(!buf) _seam_fatal("Failed to allocate buf for float to string!");
	snprintf(buf, expected + 1, "%f", input);
	_make_node(buf);
	return buf;
}

float _convert_int_to_float(int input){
	return (float) input;
}

int _convert_float_to_int(float input){
	return (int) input;
}

/* 'screen' entity */

void _screen_out(char* message){
	fprintf(stdout, "%s\n", message);
}

void _screen_init(int width, int height){
    if(window_inited){
		_seam_fatal("Tried to initialize SDL window twice!");
	}
		
    //Create a window and a surface we can draw to
	sdl_window = SDL_CreateWindow("SEAMScript Application",
		SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
        width, height, SDL_WINDOW_SHOWN );
	if(!sdl_window){
		char buf[1000];
		sprintf(buf, "Window could not be created! SDL_Error: %s",
			SDL_GetError());
		_seam_fatal(buf);
	} else {
		sdl_screen_surface = SDL_GetWindowSurface(sdl_window);
	}

	window_inited = 1;
}

void _screen_stop(){
	if(window_inited){
		SDL_FreeSurface(sdl_screen_surface);
		SDL_DestroyWindow(sdl_window);
	} else {
		_seam_fatal("Tried teardown a non-existent SDL context!");
	}

	window_inited = 0;
}

//Pause the program for x milliseconds. Not exported to user programs.
void _screen_delay(int milliseconds){
    SDL_Delay(milliseconds);
}

//Set the background of the screen
void _screen_set_background(int color){	
	SDL_FillRect(sdl_screen_surface, NULL, color);
	SDL_UpdateWindowSurface(sdl_window);
}

//Draw a texture to the screen
void _screen_draw(texture* tex, int x, int y){
	SDL_Rect src;
	SDL_Rect dst;

	src.x = 0;
	src.y = 0;
	src.w = tex->width;
	src.h = tex->height;

	dst.x = x;
	dst.y = y;
	dst.w = tex->width;
	dst.h = tex->height;

	SDL_BlitSurface(tex->surface, &src, sdl_screen_surface, &dst);
	SDL_UpdateWindowSurface(sdl_window);
}

/* texture support -- not part of screen! represented with load(...)
   and unload(...) keywords! */

texture* _load_tex(char* path){
	SDL_Surface* sdl_img = SDL_LoadBMP(path);
	if(!sdl_img) _seam_fatal("Error loading BMP!");

	texture* result = malloc(sizeof(texture));
	if(!result) _seam_fatal("Failed to allocate space for surface!");
	result->surface = sdl_img;
	result->width = sdl_img->w;
	result->height = sdl_img->h;

	return result;
}

void _unload_tex(texture* tex){
	if(tex){
		SDL_FreeSurface(tex->surface);
		free(tex);
	}
}

/* 'keyboard' entity */

//Add polled events to event list
void _keyboard_poll_events(){
	SDL_Event event;

	keyboard_node* node;
	while(SDL_PollEvent(&event)){
		switch(event.type){
			case SDL_KEYDOWN:
			case SDL_KEYUP:
				node = malloc(sizeof(keyboard_node));
				
				node->press_type = event.type;
				node->key = event.key.keysym.sym;
				node->next = NULL;

				if(khead){
					keyboard_node* curr = khead;
					while(curr->next) curr = curr->next;
					curr->next = node;
				} else {
					khead = node;
				}
				break;
			case SDL_QUIT:
				quit_requested = 1;
				break;
		}
	}
}

void _check_quit_requested(){
	_keyboard_poll_events();
}

//Check if a key (determined by its scan code) is down or up.
int _keyboard_event_check(int type, int code){
	keyboard_node* prev = NULL;
	keyboard_node* curr = khead;
	while(curr){
		if(curr->key == code && curr->press_type == type){
			//Remove from list and stitch list back together
			if(prev)
				prev->next = curr->next;
			else
				khead = curr->next;
			free(curr);
			return 1;
		}
		prev = curr;
		curr = curr->next;
	}

	return 0;

}

int _keyboard_keydown(int code){
	_keyboard_poll_events();
	return _keyboard_event_check(SDL_KEYDOWN, code);
}

int _keyboard_keyup(int code){
	_keyboard_poll_events();
	return _keyboard_event_check(SDL_KEYUP, code);
}
